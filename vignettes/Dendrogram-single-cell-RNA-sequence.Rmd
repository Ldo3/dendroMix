---
title: "Dendrogram-single-cell-RNA-sequence"
author: Linh Do, Dat Do
output:
  rmarkdown::html_vignette:
    code_folding: hide
vignette: >
  %\VignetteIndexEntry{Dendrogram-single-cell-RNA-sequence}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

We consider an application of the dendrogram of mixing measures in Single-cell RNA-sequencing data presented in Grace XY Zheng et al (2017), where they collected 68,000 peripheral blood mononuclear cells and labelled them based on expression profiles of 11 reference transcriptomes from known cell types. There are five cell types in the dataset: memory T cells, B cells, naive T cells, natural killer cells, and monocytes. After cleaning the data (dropping low-count cells and performing log pseudo-count transform), there are 41,159 cells left. The result of this experiment is reported in our paper Section 5.4. 


We project the unlabeled data onto the first 10 Principal Component (PC) spaces and fit with a mixture of location-scale Gaussians with 15 components. We then visualize the 15-atom mixing measure with the dendrogram constructed.


```{r loading packages, message=FALSE, warning=FALSE}
library(dendroMix)
library(ggplot2)
library(mclust)
library(patchwork)
library(mvtnorm)
library(matrixStats)
```


```{r loading data, warning=FALSE, message=FALSE}
data("tcell_id")
data("bcell_id")
data("mono_id")
data("nk_id")
data("naive_id")
sce <- load_sce_processed()

# Initialize color_list if not yet created (replace N with total number of cells)
N <- 10000  # replace this with your actual length
color_list <- rep(NA_integer_, N)

# Flatten and adjust inDSCes (-1 because Python is 0-based)
tcell_id <- as.vector(tcell_id) - 1
bcell_id <- as.vector(bcell_id) - 1
mono_id  <- as.vector(mono_id) - 1
nk_id    <- as.vector(nk_id) - 1
naive_id <- as.vector(naive_id) - 1

# Assign colors
color_list[tcell_id + 1] <- 0  # +1 since R is 1-based
color_list[bcell_id + 1] <- 1
color_list[mono_id + 1]  <- 2
color_list[nk_id + 1]    <- 3
color_list[naive_id + 1] <- 4
```

Visualizing the data after applying PCA with 10 components.

```{r pca}
# --- Prepare matrix: make rows = cells ---
sce_mat <- sce$x
N <- nrow(sce_mat)

# --- Figure out whether IDs are 0- or 1-based, then make a cell_type vector ---
all_ids <- c(tcell_id, bcell_id, mono_id, nk_id, naive_id)
# Heuristic: if max ID equals N-1, it's 0-based; if equals N, it's 1-based
offset <- if (max(all_ids, na.rm = TRUE) == N - 1) 1L else 0L

cell_type <- rep("Other/Unknown", N)

set_label <- function(id_vec, label) {
     if (is.null(id_vec)) return(invisible())
     idx <- as.integer(as.vector(id_vec)) + offset
     idx <- idx[idx >= 1 & idx <= N & !is.na(idx)]
     cell_type[idx] <<- label
}

set_label(tcell_id,  "T cell")
set_label(bcell_id,  "B cell")
set_label(mono_id,   "Monocyte")
set_label(nk_id,     "NK cell")
set_label(naive_id,  "Naive")

cell_type <- factor(cell_type, levels = c("T cell","B cell","Monocyte","NK cell","Naive","Other/Unknown"))

# --- Grab first two of the processed PCA for plotting ---
pc2 <- as.data.frame(sce$x[, 1:2, drop = FALSE])
names(pc2) <- c("PC1","PC2")
pc2$cell_type <- cell_type

#Extract the transformed data
lowdim_data <- sce$x
dim(lowdim_data)  

# Compute explained variance ratio
explained_var <- sce$sdev^2 / sum(sce$sdev^2)
df_var <- data.frame(
  PC = seq_along(explained_var),
  Cumulative = cumsum(explained_var)
)

```

```{r pca plot, fig.alt="Visualization"}
# Plot cumulative explained variance
ggplot(df_var, aes(x = PC, y = Cumulative)) +
  geom_line(color = "steelblue", linewidth = 1) +
  # geom_point(color = "steelblue") +
  geom_hline(yintercept = 0.9, linetype = "dashed", color = "red") +
  labs(
    title = "PCA Explained Variance (10 components)",
    x = "Number of Components",
    y = "Cumulative Explained Variance"
  ) +
  theme_minimal()

ggplot(pc2, aes(PC1, PC2, color = cell_type)) +
  geom_point(alpha = 0.7, size = 1) +
  labs(title = "Cells in PC space (colored by type)", x = "PC1", y = "PC2", color = "Cell type") +
  theme_minimal()

```


```{r overfit with mclust, warning=FALSE,message=FALSE}
K_bar <- 15

# Fit Gaussian Mixture Model (full covariance by default)
gmm <- Mclust(lowdim_data, G = K_bar, modelNames = "VVV")  # "VVV" = variable volume, shape, orientation

# View results
summary(gmm)

```

```{r dendrogram and plots, fig.alt="Dendrogram of the first two dimensions"}
# Means of each component (columns = features)
  mus_hat <- t(gmm$parameters$mean)     
  
  # Mixing weights
  p_hat <- gmm$parameters$pro         
  
  # Covariance matrices 
  sigmas_hat = gmm$parameters$variance$sigma
  Sigma_list <- lapply(seq_len(dim(sigmas_hat)[3]), function(k) sigmas_hat[,,k])
  dmm = dendrogram_mixing(ps = p_hat,
                          thetas = mus_hat,
                          sigmas = Sigma_list)
  
  main_title = paste("Dendrogram in the first PC")
  plot_dendrogram_mixing(dmm, dim = 1,point_size = 1, main=main_title)
  
  main_title = paste("Dendrogram in the second PC")
  plot_dendrogram_mixing(dmm, dim = 2,point_size = 1, main=main_title)
```

# Dendrogram Selection Criterion

We provide an example of using the Dendrogram Selection Criterion (DSC) in selecting model from the constructed dendrogram.

```{r loglikelihood}
loglikelihood_GMM <- function(X, pi, mu, Sigma) {
     # X: n x d numeric matrix
     # pi: length-k numeric vector (mixing weights)
     # mu: k x d numeric matrix (means; rows = components)
     # Sigma: a list of length k with d x d matrices, or a 3D array d x d x k
     
     X <- as.matrix(X)
     k <- length(pi)
     n <- nrow(X)
     d <- ncol(X)
     
     stopifnot(ncol(mu) == d, nrow(mu) == k)
     
     getSigma <- function(j) {
          if (is.list(Sigma)) {
               Sigma[[j]]
          } else {
               Sigma[,,j]
          }
     }
     
     # log p(x_i | comp j) + log pi_j, computed for ALL i at once per j
     log_pi <- log(pi)
     logdens_mat <- vapply(
          X = seq_len(k),
          FUN = function(j) mvtnorm::dmvnorm(X, mean = mu[j, ], sigma = getSigma(j), log = TRUE) + log_pi[j],
          FUN.VALUE = numeric(n)
     )
     # log-sum-exp per row
     m <- matrixStats::rowMaxs(logdens_mat)
     sum(m + log(rowSums(exp(logdens_mat - m))))
}


llh <- numeric(K_bar)
K_list <- K_bar:1

for (i in seq_len(K_bar)) {
     pi_i    <- as.vector(dmm$Gs[[i]]$ps)
     mu_i    <- as.matrix(dmm$Gs[[i]]$thetas)     # ensure k x d (rows = components)
     Sigma_i <- dmm$Gs[[i]]$sigmas                # list or 3D array is fine
     
     # If your thetas are d x k, flip them:
     if (nrow(mu_i) != length(pi_i)) mu_i <- t(mu_i)
     
     llh[i] <- loglikelihood_GMM(lowdim_data, pi_i, mu_i, Sigma_i)
}


```


```{r DSC, fig.alt="DSC"}
# d_list = (dmm$hc$height)
d_list = cumsum(dmm$hc$height)
## --- Compute DSC
rescale_d <- sqrt(d_list) / max(sqrt(d_list))
n = nrow(lowdim_data)
DSC <- -(rescale_d + log(n) / abs(llh[1] / n) * llh[-length(llh)] / n)  
DSC <- rev(DSC)

choice_k_DSC <- which.min(DSC)+1

## --- Panel A: DSC curve ---
df1 <- data.frame(
  k = 2:15,
  DSC = DSC
)

p1 <- ggplot(df1, aes(k, DSC)) +
  geom_line(linewidth = 0.8, color = "blue") +
  geom_point(shape = 21, size = 3, fill = "blue", color = "blue") +
  geom_vline(xintercept = choice_k_DSC, linetype = "dashed", color = "deepskyblue") +
  annotate("text", x = choice_k_DSC, y = max(df1$DSC, na.rm = TRUE),
           label = paste0("DSC finds ", choice_k_DSC, " components"),
           vjust = 0.1, hjust = 0, color = "deepskyblue", size = 3) +
  scale_x_continuous(breaks = df1$k, limits = c(2, 16)) +
  labs(
    x = "Number of components",
    y = "Selection Criterion",
    title = " DSC scores"
  ) +
  theme_bw() +
  theme(plot.title.position = "plot",
        plot.title = element_text(margin = margin(b = 10), vjust = -0.2))

## --- Panel B: Heights between levels in dendrogram ---
d_rev <- rev(d_list)                     
k_vals <- 2:(length(d_rev) + 1)          

df2 <- data.frame(
  k = k_vals,
  height = d_rev
)

p2 <- ggplot(df2, aes(k, height)) +
  geom_point(size = 3) +
  geom_line(linetype = "dashed") +
  scale_x_continuous(breaks = k_vals) +
  labs(
    x = "Number of components",
    y = "Height of dendrogram",
    title = "Height at levels in dendrogram"
  ) +
  theme_bw() +
  theme(plot.title.position = "plot",
        plot.title = element_text(margin = margin(b = 10), vjust = -0.2))


p1 | p2
```

